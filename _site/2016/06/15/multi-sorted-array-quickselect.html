<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Quickselect on multiple sorted arrays</title>
  <meta name="description" content="Edit: Thanks heaps to Evgeny Kluev, the author of that original StackOverflow answer, for noticing that I’d made a mistake in the total time complexity calcu...">


  <link rel="stylesheet" href="/stylesheets/styles.css">
  <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <link rel="canonical" href="http://danielfilan.com//2016/06/15/multi-sorted-array-quickselect.html">
  <link rel="alternate" type="application/rss+xml" title="Daniel Filan" href="http://danielfilan.com//feed.xml">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$$', '$$'] ],
        displayMath: [ ['$^$', '$^$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      messageStyle: "none",
      "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
    });
  </script>
  <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
</head>


  <body>

    

    <div class="wrapper">
  <header>
  <h1><a href="/">Daniel Filan</a></h1>
  <img src="https://scontent-sjc2-1.xx.fbcdn.net/v/t1.0-9/11659278_10202944584654914_2762452412152680044_n.jpg?oh=f017f593bd04d84d5de68bb00a736ddf&oe=58486651"/>
  <ul>
    <li><a href="/pdfs/cv.pdf">CV</a></li>
    <li><a href="mailto:df@danielfilan.com">email</a></li>
    <li><a href="/daniel_filan_public_key.asc">PGP public key</li>
    <li><a href="https://github.com/dfilan">github</a></li>
    <li><a href="/posts">blog</a></li>
  </ul>
</header>


  <section>
    <h2>Quickselect on multiple sorted arrays</h2>
    <p><strong>Edit: Thanks heaps to <a href="http://stackoverflow.com/users/1009831/evgeny-kluev">Evgeny Kluev</a>, the author of that original StackOverflow answer, for noticing that I’d made a mistake in the total time complexity calculation.</strong></p>

<p><strong>Edit 2016-06-18: I’d orignally described this with arrays of maximum length <script type="math/tex">n</script>. But it works just as well with arrays of average length <script type="math/tex">n</script>, which is a stronger statement, so I’d rather use this one.</strong></p>

<p>Suppose I have <script type="math/tex">m</script> sorted arrays of average length <script type="math/tex">n</script>. How quickly can I search to find the <script type="math/tex">k</script>th item in them?</p>

<p><a href="http://stackoverflow.com/a/26299986/1360429">This StackOverflow answer</a> mentions this problem offhandedly, but doesn’t clearly explain the algorithm, and it implies that the answer it’s thinking of is <script type="math/tex">O(m^2 \log(n)^2)</script>.</p>

<p>We can do better. You can modify quickselect to get an algorithm which takes <script type="math/tex">O(m \log(n) \log(m \cdot n))</script> average case, and I suspect you can adapt <a href="https://en.wikipedia.org/wiki/Median_of_medians">median of medians</a> to get that time in the worst case.</p>

<p>The quickselect adaptation is pretty simple. We’re going to be do a simultaneous binary search on every array. For simplicity, let’s assume that all items in arrays are unique.</p>

<p>We’re going to need a <code class="highlighter-rouge">rank</code> method, which does a binary search to determine the number of items in an array smaller than its argument <code class="highlighter-rouge">x</code>. Here is such a method:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="c1"># Returns the number of items in arr smaller than x.</span>
<span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">arr</span><span class="p">.</span><span class="nf">empty?</span>

  <span class="n">end_idx</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span> <span class="k">if</span> <span class="n">end_idx</span><span class="p">.</span><span class="nf">nil?</span>

  <span class="c1"># this makes sense I promise, I'll explain later</span>
  <span class="k">return</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span> <span class="k">if</span> <span class="n">start_idx</span> <span class="o">==</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span>
  <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">end_idx</span> <span class="o">==</span> <span class="mi">0</span>

  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">mid_idx</span> <span class="o">=</span> <span class="p">((</span><span class="n">start_idx</span> <span class="o">+</span> <span class="n">end_idx</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">).</span><span class="nf">floor</span>

    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid_idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span>
      <span class="k">return</span> <span class="n">mid_idx</span>
    <span class="k">elsif</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span>
      <span class="k">return</span> <span class="n">start_idx</span> <span class="k">if</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">&lt;=</span> <span class="mi">1</span>
      <span class="n">end_idx</span> <span class="o">=</span> <span class="n">mid_idx</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">end_idx</span> <span class="k">if</span> <span class="n">end_idx</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">&lt;=</span> <span class="mi">1</span>
      <span class="n">start_idx</span> <span class="o">=</span> <span class="n">mid_idx</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Now here’s how the select method is going to work. We’re going to start by setting up a <code class="highlighter-rouge">limits</code> variable. Normally in binary search, you need to store two variables, <code class="highlighter-rouge">start_idx</code> and <code class="highlighter-rouge">end_idx</code>. In our case, we’re going to store these two variables for every array we’re working with.</p>

<p>Every iteration, we’re going to randomly choose a pivot from the elements that haven’t been ruled out yet. Then we’re going to binary search all of the arrays to find the rank of the pivot in each of the arrays. We can add all these ranks together to find the rank of the pivot overall.</p>

<p>If the rank of the pivot is equal to <code class="highlighter-rouge">k</code>, then we return our pivot and stop recursing.</p>

<p>If the rank of the pivot is greater than <code class="highlighter-rouge">k</code>, our pivot is larger than the true result. So we can rule out every value which is larger than our pivot. For every array, we set its <code class="highlighter-rouge">end_idx</code> to the rank which it computed for the pivot.</p>

<p>If the rank of the pivot is smaller than k, then do the opposite: set the <code class="highlighter-rouge">start_idx</code> array to the rank array.</p>

<p>Here’s an implementation of that:</p>

<div class="language-ruby highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quickselect_in_sorted_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">length</span> <span class="o">==</span> <span class="mi">1</span>

  <span class="n">arrays</span><span class="p">.</span><span class="nf">select!</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">}</span>

  <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:count</span><span class="p">).</span><span class="nf">reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="p">:</span><span class="o">+</span><span class="p">)</span>

  <span class="c1"># In a single binary search, we have variables `start_idx`</span>
  <span class="c1"># and `end_idx`.</span>

  <span class="c1"># In this binary search, we need those variables for</span>
  <span class="c1"># every array. So we'll keep them in these arrays.</span>
  <span class="n">start_indexes</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="n">end_indexes</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">arr</span><span class="o">|</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span> <span class="p">}</span>

  <span class="kp">loop</span> <span class="k">do</span>
    <span class="c1"># Randomly select an item from the viable candidates.</span>
    <span class="c1"># (This is obviously not an efficient implementation)</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">map</span>
                  <span class="p">.</span><span class="nf">with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
                    <span class="n">arr</span><span class="p">[</span><span class="n">start_indexes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">end_indexes</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                  <span class="k">end</span>
                  <span class="p">.</span><span class="nf">flatten</span>
                  <span class="p">.</span><span class="nf">sample</span>


    <span class="c1"># Find the rank of the pivot in every array.</span>
    <span class="n">pivot_ranks</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">.</span><span class="nf">map</span><span class="p">.</span><span class="nf">with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
      <span class="n">rank</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">start_indexes</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">end_indexes</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">end</span>

    <span class="c1"># What is `pivot`'s overall rank in these arrays?</span>
    <span class="n">overall_rank_of_pivot</span> <span class="o">=</span> <span class="n">pivot_ranks</span><span class="p">.</span><span class="nf">reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="p">:</span><span class="o">+</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">overall_rank_of_pivot</span> <span class="o">==</span> <span class="n">k</span>
      <span class="c1"># we're done! woohoo!</span>
      <span class="k">return</span> <span class="n">pivot</span>
    <span class="k">elsif</span> <span class="n">overall_rank_of_pivot</span> <span class="o">&gt;</span> <span class="n">k</span>
      <span class="c1"># our pivot was apparently too big.</span>

      <span class="c1"># On the plus side, we now know that wherever our binary</span>
      <span class="c1"># searches just finished, everything to the right of that</span>
      <span class="c1"># in that array is now guaranteed not to be the result.</span>
      <span class="n">pivot_ranks</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">rank</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
        <span class="n">end_indexes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
      <span class="k">end</span>
    <span class="k">else</span>
      <span class="c1"># If our pivot was too small, then we can rule out</span>
      <span class="c1"># everything to the left of those ranks.</span>
      <span class="n">pivot_ranks</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">rank</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
        <span class="n">start_indexes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>For full source code including some random testcases, <a href="https://gist.github.com/bshlgrs/14801efbb27d447fa7a2afba97ab70b4">look here</a>.</p>

<p>How fast is this method? The main loop costs <script type="math/tex">m \log(n)</script> per iteration. How many times will we run it? Well, every time we run the iteration, we cut out all the elements which are on the wrong side of the result from our pivot. Worst case, we keep choosing the worst possible pivot and only ruling it out, which means we need to run that iteration once for every item in all of the arrays. This is <script type="math/tex">O(m^2 n \log(n))</script>.</p>

<p>But on average, we’ll cut a constant fraction of our search space out every time. So we should expect to have to do that iteration <script type="math/tex">\log(m\cdot n) = \log(m) + \log(n)</script> times, for an overall time complexity of <script type="math/tex">O(m \log(n) \log(m \cdot n))</script>.</p>

<p>(Incidentally, when I was initially thinking about this, I thought we might get some speedup because our call to <code class="highlighter-rouge">rank</code> is going to be on a smaller and smaller section of its array every iteration throuhgh the loop. But I don’t think that’s true, because to get an asympotic decrease in the sum of a bunch of logarithms, you need to make your problem sizes decrease extremely quickly; exponentially decaying problem size doesn’t cut it. For example:</p>

<p>$^$O\left(\sum_{i=0}^n \log\left(2^i\right) \right) = O(\log(n)^2) = O\left(\sum_{i=0}^n \log\left(2^n\right) \right)$^$</p>

<p>because</p>

<p>$^$O\left(\sum_{i=0}^n i \right) = O(n^2) = O\left(\sum_{i=0}^n n \right)$^$</p>

<p>So I don’t think we can make that work.)</p>

<h2 id="further-questions">Further questions</h2>

<ul>
  <li>Can we generalize the <a href="https://en.wikipedia.org/wiki/Median_of_medians">median of medians</a> algorithm to get this to be guaranteed fast, rather than expected fast? The answer is almost certainly yes; I’ll probably try to prove it sometime.</li>
</ul>

  </section>
</div>



  </body>

<script>
if (window.location.hostname == "dfilan.github.io") {
  window.location.hostname = "shlegeris.com";
}
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52980069-1', 'auto');
  ga('send', 'pageview');

</script>



</html>

